' Gambas class file

' Description:
' CRFXComTrx.class
' Connect to RFXCom TRX transceiver interface via tcp socket or serial port.

' Development Status:
' Used RFXCom's RFXmngr_vb project as example.

' Credits:
' Thanks to Bert Weijenberg/RFXCom for letting me test new hardware products.

' DomotiGa - an open source home automation program.
' Copyright(C) 2008-2012 Ron Klinkien

' Read file called COPYING for license details.

PROPERTY TCPHost AS String
PROPERTY TCPPort AS Integer
PROPERTY RFXComDebug AS Boolean

PRIVATE sTCPHost AS String
PRIVATE iTCPPort AS Integer
PRIVATE bRFXComTRXDebug AS Boolean
PRIVATE bOldAddrFmt AS Boolean = TRUE

PUBLIC hRFXComTRX AS NEW Socket
PUBLIC tRFXComTRXConnect AS Timer
PUBLIC tRFXComTRXReset AS Timer
PRIVATE bResetActive AS Boolean = TRUE
PRIVATE iConnectRetry AS Integer = 0 ' retries
PRIVATE iConnectDelay AS Integer = 60000 ' 1 minute

PRIVATE RecBuf As New Byte[30]
PRIVATE RecBytes AS Byte
PUBLIC bSimulate AS Boolean
PRIVATE iSeq AS Integer

' interface control
CONST pTypeInterfaceControl AS Byte = &H0
CONST sTypeInterfaceCommand AS Byte = &H0

CONST pTypeInterfaceMessage AS Byte = &H1
CONST sTypeInterfaceResponse AS Byte = &H0

' interface commands
CONST cmdRESET AS Byte = &H0 ' reset the receiver/transceiver
CONST cmdSTATUS AS Byte = &H2 ' return firmware versions and configuration of the interface
CONST cmdSETMODE AS Byte = &H3 ' set the configuration of the interface
CONST cmdENABLEALL AS Byte = &H4 ' enable all receiving modes of the receiver/transceiver
CONST cmdUNDECODED AS Byte = &H5 ' display undecoded messages
CONST cmdSAVE AS Byte = &H6 ' save receiving modes of the receiver/transceiver in non-volatile memory
CONST cmdDISX10 AS Byte = &H10 ' disable receiving of X10
CONST cmdDISARC AS Byte = &H11 ' disable receiving of ARC
CONST cmdDISAC AS Byte = &H12 ' disable receiving of AC
CONST cmdDISHEU AS Byte = &H13 ' disable receiving of HomeEasy EU
CONST cmdDISKOP AS Byte = &H14 ' disable receiving of Ikea-Koppla
CONST cmdDISOREGON AS Byte = &H15 ' disable receiving of Oregon Scientific
CONST cmdDISATI AS Byte = &H16 ' disable receiving of ATI Remote Wonder
CONST cmdDISVISONIC AS Byte = &H17 ' disable receiving of Visonic
CONST cmdDISMERTIK AS Byte = &H18 ' disable receiving of Mertik
CONST cmdDISAD AS Byte = &H19 ' disable receiving of AD
CONST cmdDISHID AS Byte = &H1A ' disable receiving of Hideki
CONST cmdDISLCROS AS Byte = &H1B ' disable receiving of La Crosse
CONST cmdDISFS20 AS Byte = &H1C ' disable receiving of FS20
CONST cmdDISNOVAT AS Byte = &H1D ' disable receiving of Novatys

CONST cmd310 AS Byte = &H50 ' select 310MHz in the 310/315 transceiver
CONST cmd315 AS Byte = &H51 ' select 315MHz in the 310/315 transceiver
CONST cmd830 AS Byte = &H57 ' select 868.30MHz ASK in the 868 transceiver
CONST cmd830F AS Byte = &H58 ' select 868.30MHz FSK in the 868 transceiver
CONST cmd835 AS Byte = &H59 ' select 868.35MHz ASK in the 868 transceiver
CONST cmd835F AS Byte = &H5A ' select 868.35MHz FSK in the 868 transceiver
CONST cmd895 AS Byte = &H5B ' select 868.95MHz in the 868 transceiver

CONST pTypeRecXmitMessage AS Byte = &H2
CONST sTypeReceiverLockError AS Byte = &H0
CONST sTypeTransmitterResponse AS Byte = &H1

' receiver
CONST pTypeResponse AS Byte = &H1
CONST recType310 AS Byte = &H50
CONST recType315 AS Byte = &H51
CONST recType43392 AS Byte = &H53
CONST recType86800 AS Byte = &H55
CONST recType86800FSK AS Byte = &H56
CONST recType86830 AS Byte = &H57
CONST recType86830FSK AS Byte = &H58
CONST recType86835 AS Byte = &H59
CONST recType86835FSK AS Byte = &H5A
CONST recType86895 AS Byte = &H5B

' undecoded
CONST pTypeUndecoded AS Byte = &H3
CONST sTypeUac AS Byte = &H0
CONST sTypeUarc AS Byte = &H1
CONST sTypeUati AS Byte = &H2
CONST sTypeUhideki AS Byte = &H3
CONST sTypeUlacrosse AS Byte = &H4
CONST sTypeUlwrf AS Byte = &H5
CONST sTypeUmertik AS Byte = &H6
CONST sTypeUoregon1 AS Byte = &H7
CONST sTypeUoregon2 AS Byte = &H8
CONST sTypeUoregon3 AS Byte = &H9
CONST sTypeUproguard AS Byte = &HA
CONST sTypeUvisonic AS Byte = &HB
CONST sTypeUnec AS Byte = &HC
CONST sTypeUfs20 AS Byte = &HD

' lighting
CONST pTypeLighting1 AS Byte = &H10
CONST sTypeX10 AS Byte = &H0
CONST sTypeARC AS Byte = &H1
CONST sTypeAB400D AS Byte = &H2
CONST sTypeWaveman AS Byte = &H3
CONST sTypeEMW200 AS Byte = &H4
CONST sTypeIMPULS AS Byte = &H5

CONST pTypeLighting2 AS Byte = &H11
CONST sTypeAC AS Byte = &H0
CONST sTypeHEU AS Byte = &H1
CONST sTypeANSLUT AS Byte = &H2

CONST pTypeLighting3 AS Byte = &H12
CONST sTypeKoppla AS Byte = &H0

CONST pTypeLighting4 AS Byte = &H13
CONST sTypePT2262 AS Byte = &H0

CONST pTypeLighting5 AS Byte = &H14
CONST sTypeLightwaveRF AS Byte = &H0

' curtain
CONST pTypeCurtain AS Byte = &H18
CONST sTypeHarrison AS Byte = &H0

' security
CONST pTypeSecurity1 AS Byte = &H20
CONST sTypeSecX10 AS Byte = &H0
CONST sTypeSecX10M AS Byte = &H1
CONST sTypeSecX10R AS Byte = &H2
CONST sTypeKD101 AS Byte = &H3
CONST sTypePowercodeSensor AS Byte = &H4
CONST sTypePowercodeMotion AS Byte = &H5
CONST sTypeCodesecure AS Byte = &H6
CONST sTypePowercodeAux AS Byte = &H7

' status security
CONST sStatusNormal AS Byte = &H0
CONST sStatusNormalDelayed AS Byte = &H1
CONST sStatusAlarm AS Byte = &H2
CONST sStatusAlarmDelayed AS Byte = &H3
CONST sStatusMotion AS Byte = &H4
CONST sStatusNoMotion AS Byte = &H5
CONST sStatusPanic AS Byte = &H6
CONST sStatusPanicOff AS Byte = &H7
CONST sStatusTamper AS Byte = &H8
CONST sStatusArmAway AS Byte = &H9
CONST sStatusArmAwayDelayed AS Byte = &HA
CONST sStatusArmHome AS Byte = &HB
CONST sStatusArmHomeDelayed AS Byte = &HC
CONST sStatusDisarm AS Byte = &HD
CONST sStatusLightOff AS Byte = &H10
CONST sStatusLightOn AS Byte = &H11
CONST sStatusLight2Off AS Byte = &H12
CONST sStatusLight2On AS Byte = &H13
CONST sStatusDark AS Byte = &H14
CONST sStatusLight AS Byte = &H15
CONST sStatusBatLow AS Byte = &H16
CONST sStatusPairKD101 AS Byte = &H17

' camera1
CONST pTypeCamera1 AS Byte = &H28
CONST sTypeNinja AS Byte = &H0

' remotes
CONST pTypeRemote AS Byte = &H30
CONST sTypeATI AS Byte = &H0
CONST sTypeATI2 AS Byte = &H1
CONST sTypeMedion AS Byte = &H2
CONST sTypePCremote AS Byte = &H3

' thermostat1
CONST pTypeThermostat1 AS Byte = &H40
CONST sTypeDigimax AS Byte = &H0    ' Digimax with long packet
CONST sTypeDigimax1 AS Byte = &H1   ' Digimax with short packet (no set point)

' thermostat2
CONST pTypeThermostat2 AS Byte = &H41
CONST sTypeHE105 AS Byte = &H0  ' HE105
CONST sTypeRTS10 AS Byte = &H1  ' RTS10

' thermostat3
CONST pTypeThermostat3 AS Byte = &H42
CONST sTypeMertikG6RH4T1 AS Byte = &H0  ' Mertik G6R-H4T1
CONST sTypeMertikG6RH4TB AS Byte = &H1  ' Mertik G6R-H4TB

' temperature
CONST pTypeTEMP AS Byte = &H50
CONST sTypeTEMP1 AS Byte = &H1  ' THR128/138, THC138
CONST sTypeTEMP2 AS Byte = &H2  ' THC238/268,THN132,THWR288,THRN122,THN122,AW129/131
CONST sTypeTEMP3 AS Byte = &H3  ' THWR800
CONST sTypeTEMP4 AS Byte = &H4  ' RTHN318
CONST sTypeTEMP5 AS Byte = &H5  ' LaCrosse TX3

' humidity
CONST pTypeHUM AS Byte = &H51   ' not used
CONST sTypeHUM1 AS Byte = &H1   ' LaCrosse TX3

' temperature+humidity
CONST pTypeTEMP_HUM AS Byte = &H52
CONST sTypeTH1 AS Byte = &H1    ' THGN122/123,/THGN132,THGR122/228/238/268
CONST sTypeTH2 AS Byte = &H2    ' THGR810
CONST sTypeTH3 AS Byte = &H3    ' RTGR328
CONST sTypeTH4 AS Byte = &H4    ' THGR328
CONST sTypeTH5 AS Byte = &H5    ' WTGR800
CONST sTypeTH6 AS Byte = &H6    ' THGR918,THGRN228,THGN500
CONST sTypeTH7 AS Byte = &H7    ' TFA TS34C
CONST sTypeTH8 AS Byte = &H8    ' WT440H/450H

' barometric
CONST pTypeBARO AS Byte = &H53  ' not used

' temperature+humidity+baro
CONST pTypeTEMP_HUM_BARO AS Byte = &H54
CONST sTypeTHB1 AS Byte = &H1   ' BTHR918
CONST sTypeTHB2 AS Byte = &H2   ' BTHR918N,BTHR968

' rain
CONST pTypeRAIN AS Byte = &H55
CONST sTypeRAIN1 AS Byte = &H1  ' RGR126/682/918
CONST sTypeRAIN2 AS Byte = &H2  ' PCR800
CONST sTypeRAIN3 AS Byte = &H3  ' TFA

' wind
CONST pTypeWIND AS Byte = &H56
CONST sTypeWIND1 AS Byte = &H1  ' WTGR800
CONST sTypeWIND2 AS Byte = &H2  ' WGR800
CONST sTypeWIND3 AS Byte = &H3  ' STR918,WGR918
CONST sTypeWIND4 AS Byte = &H4  ' TFA

' uv
CONST pTypeUV AS Byte = &H57
CONST sTypeUV1 AS Byte = &H1    ' UVN128,UV138
CONST sTypeUV2 AS Byte = &H2    ' UVN800
CONST sTypeUV3 AS Byte = &H3    ' TFA

' date & time
CONST pTypeDT AS Byte = &H58
CONST sTypeDT1 AS Byte = &H1    ' RTGR328N

' current
CONST pTypeCURRENT AS Byte = &H59
CONST sTypeELEC1 AS Byte = &H1  ' CM113,Electrisave

' energy
CONST pTypeENERGY AS Byte = &H5A
CONST sTypeELEC2 AS Byte = &H1  ' CM119/160

' gas
CONST pTypeGAS AS Byte = &H5B   ' not used

' water
CONST pTypeWATER AS Byte = &H5C ' not used

' weight scales
CONST pTypeWEIGHT AS Byte = &H5D
CONST sTypeWEIGHT1 AS Byte = &H1   ' BWR102
CONST sTypeWEIGHT2 AS Byte = &H2   ' GR101

' rfxsensor
CONST pTypeRFXSensor AS Byte = &H70
CONST sTypeRFXSensorTemp AS Byte = &H0
CONST sTypeRFXSensorAD AS Byte = &H1
CONST sTypeRFXSensorVolt AS Byte = &H2
CONST sTypeRFXSensorMessage AS Byte = &H3

' rfxmeter
CONST pTypeRFXMeter AS Byte = &H71
CONST sTypeRFXMeterCount AS Byte = &H0
CONST sTypeRFXMeterInterval AS Byte = &H1
CONST sTypeRFXMeterCalib AS Byte = &H2
CONST sTypeRFXMeterAddr AS Byte = &H3
CONST sTypeRFXMeterCounterReset AS Byte = &H4
CONST sTypeRFXMeterCounterSet AS Byte = &HB
CONST sTypeRFXMeterSetInterval AS Byte = &HC
CONST sTypeRFXMeterSetCalib AS Byte = &HD
CONST sTypeRFXMeterSetAddr AS Byte = &HE
CONST sTypeRFXMeterIdent AS Byte = &HF

PUBLIC SUB RFXComTRX_Ready()

  Main.WriteLog(("[RFXComTRX] Transceiver TCP socket connected."))

  ' define timer for RFXComTRX reconnect
  tRFXComTRXConnect = NEW Timer AS "tRFXComTRXConnect"
  tRFXComTRXConnect.Delay = iConnectRetry
  tRFXComTRXConnect.Stop

  ' define timer for RFXComTRX reset
  tRFXComTRXReset = NEW Timer AS "tRFXComTRXReset"
  tRFXComTRXReset.Delay = 1000
  tRFXComTRXReset.Stop

END

' just here for development/debuggingi
PUBLIC SUB ParseDump(sFile AS String)

  DIM hFile AS File
  DIM sLine AS String

  TRY hFile = OPEN sFile FOR INPUT
  IF ERROR THEN RETURN

  WHILE NOT Eof(hFile)
    LINE INPUT #hFile, sLine
    IF Len(sLine) > 5 THEN Simulate(sLine)
  WEND

END

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' reconnect routine
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
PUBLIC SUB tRFXComTRXConnect_Timer()

  IF NOT ConnectTCP() THEN
    INC iConnectRetry
    iConnectDelay *= iConnectRetry
    tRFXComTRXConnect.Delay = iConnectDelay
  ENDIF

END

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' reset routine
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
PUBLIC SUB tRFXComTRXReset_Timer()

  tRFXComTRXReset.Stop
  ProtocolSetup("STATUS")

END

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' connect to the host:port
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
PUBLIC FUNCTION ConnectTCP() AS Boolean

  ' try to close the connection
  TRY hRFXComTRX.Close

  ' get a new one
  hRFXComTRX = NEW Socket AS "RFXComTRX"
  hRFXComTRX.Connect(sTCPHost, iTCPPort)

  ' all ok
  RETURN TRUE

CATCH ' some errors
  Main.WriteLog(("[RFXComTRX] Transceiver Error: ") & ERROR.Text & " at " & ERROR.Where)
  RETURN FALSE

END

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' reset interface
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
PUBLIC FUNCTION ResetInterface()

  ProtocolSetup("RESET")

END

PUBLIC SUB SendCommand(sAddress AS String, sCmd AS String)

  DIM iDeviceId AS Integer
  DIM sType AS String

  SELECT UCase(sType)
    CASE "X10", "ARC", "AB400", "WAVEMAN", "EMW200", "IMPULS" ' Lightning1
      Lighting1(sType, sAddress, sCmd)
    CASE "AC", "HEEU", "ANSLUT" ' Lightning2
      Lighting2(sType, sAddress, sCmd)
    CASE "LIGHTWAVERF" ' Lightning5
      Lighting5(sType, sAddress, sCmd)
    CASE "HARRISON" ' Curtain1
      Curtain(sType, sAddress, sCmd)
    CASE ELSE
      Main.WriteDebugLog(("[RFXComTRX] " & sType & " protocol is not (yet) supported by RFXComTRX code!"))
      RETURN
  END SELECT

END

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' protocol commands
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
PUBLIC FUNCTION ProtocolSetup(sType AS String)

  DIM bCmd As New Byte[14]
  DIM b AS Byte
  DIM sText AS String

  bCmd[0] = &HD
  bCmd[1] = pTypeInterfaceControl
  bCmd[2] = sTypeInterfaceCommand
  bCmd[3] = iSeq

  SELECT sType
    CASE "RESET"
      bCmd[4] = cmdRESET
      sText = ("Reset receiver/transceiver")
    CASE "UNDECODED"
      bCmd[4] = cmdUNDECODED
      sText = ("UnDecoded On")
    CASE "STATUS"
      bCmd[4] = cmdSTATUS
      sText = ("Get status")
    CASE "ALL"
      bCmd[4] = cmdENABLEALL
      sText = ("Enable ALL RF")
    CASE "X10"
      bCmd[4] = cmdDISX10
      sText = ("Disable X10 RF")
    CASE "ARC"
      bCmd[4] = cmdDISARC
      sText = ("Disable ARC RF")
    CASE "AC"
      bCmd[4] = cmdDISAC
      sText = ("Disable AC RF")
    CASE "OREGON"
      bCmd[4] = cmdDISOREGON
      sText = ("Disable Oregon Scientific RF")
    CASE "KOPPLA"
      bCmd[4] = cmdDISKOP
      sText = ("Disable Ikea Koppla RF")
    CASE "ATI"
      bCmd[4] = cmdDISATI
      sText = ("Disable ATI Remote RF")
    CASE "VISONIC"
      bCmd[4] = cmdDISVISONIC
      sText = ("Disable Visonic RF")
    CASE "AD"
      bCmd[4] = cmdDISAD
      sText = ("Disable AD")
    CASE "HEEU"
      bCmd[4] = cmdDISHEU
      sText = ("Disable HomeEasy EU RF")
    CASE "MERTIK"
      bCmd[4] = cmdDISMERTIK
      sText = ("Disable Mertik RF")
    CASE "HIDEKI"
      bCmd[4] = cmdDISHID
      sText = ("Disable Hideki RF")
    CASE "LACROSSE"
      bCmd[4] = cmdDISLCROS
      sText = ("Disable La Crosse RF")
    CASE "FS20"
      bCmd[4] = cmdDISFS20
      sText = ("Disable FS20 RF")
    CASE "NOVATYS"
      bCmd[4] = cmdDISNOVAT
      sText = ("Disable Novatys RF")
    CASE "SAVE"
      bCmd[4] = cmdSAVE
      sText = ("Save")
    CASE ELSE
      sText = ("Unknown cmd: " & sType)
  END SELECT

  WriteCommand(bCmd)

  IF sType = "RESET" THEN
    tRFXComTRXReset.Start
    IF Main.bRFXComTRXDebug THEN Main.WriteDebugLog(("[RFXComTRX] Resetting interface, 1Sec. timer started."))
  ENDIF
  IF sType = "STATUS" THEN bResetActive = FALSE

  IF NOT bRFXComTRXDebug THEN RETURN
  Main.WriteDebugLog("[RFXComTRX] " & sText & ": ")
  FOR EACH b IN bCmd
    WriteMessage(Hex(b, 2) & " ", TRUE)
  NEXT
  Main.WriteDebugLog("\n", TRUE)

END

' ENUM TRESPONSE AS Integer
'     packetlength = 0
'     packettype = 1
'     subtype = 2
'     seqnbr = 3
'     msg = 4
' END ENUM

PUBLIC SUB Decode_RecXmitMessage()

  SELECT CASE RecBuf[2]
    CASE sTypeReceiverLockError
      WriteMessage("Subtype           = Receiver lock error")
      WriteMessage("Sequence no.      = " & CStr(RecBuf[3]))
    CASE sTypeTransmitterResponse
      WriteMessage("Subtype           = Transmitter Response")
      WriteMessage("Sequence nbr      = " & CStr(RecBuf[3]))
      SELECT CASE RecBuf[4]
        CASE &H0
          WriteMessage("Response          = ACK, data correct transmitted")
        CASE &H1
          WriteMessage("Response          = ACK, but transmit started after 6 seconds delay anyway with RF receive data detected")
        CASE &H2
          WriteMessage("Response          = NAK, transmitter did not lock on the requested transmit frequency")
        CASE ELSE
          WriteMessage("ERROR: Unexpected message type=" & Hex(RecBuf[5]))
      END SELECT
    CASE ELSE
      WriteMessage("ERROR: Unknown Sub type for Packet type=" & Hex(RecBuf[1]) & ": " & Hex(RecBuf[2]))
      RETURN
  END SELECT

END

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' send a command to the interface
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
PUBLIC FUNCTION WriteCommand(bBuffer AS Byte[])

  DIM iCnt AS Integer
  DIM sMessage AS String

  FOR iCnt = 0 TO bBuffer[0]
    sMessage &= Hex(bBuffer[iCnt], 2)
  NEXT
  IF Main.bRFXComTRXDebug THEN Main.WriteDebugLog("[RFXComTRX] > " & sMessage)

    ' send the message to the tcp stream
    TRY bBuffer.Write(hRFXComTRX, 0, bBuffer.Length)
    IF ERROR THEN Main.WriteDebugLog(("[RFXComTRX] Unable to write to TCP port! -> ") & Error.Text)
  INC iSeq
  IF iSeq = 256 THEN iSeq = 1

END

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' disconnect from the host
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
PUBLIC FUNCTION Disconnect() AS Boolean

  ' try to close the connection
  TRY hRFXComTRX.Close
  TRY tRFXComTRXConnect.Stop
  TRY tRFXComTRXReset.Stop

  Main.WriteLog(("[RFXComTRX] Transceiver TCP socket close."))

  ' all ok
  RETURN TRUE

CATCH ' some errors
  Main.WriteLog(("[RFXComTRX] Transceiver Error: ") & ERROR.Text & " at " & ERROR.Where)
  RETURN FALSE

END

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' inject packet into parser.
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
PUBLIC SUB Simulate(sPacket AS String)

  DIM iCnt AS Integer

  IF bRFXComTRXDebug THEN Main.WriteDebugLog(("[RFXComTRX] Transceiver Simulate String: ") & sPacket & "\n")

  FOR iCnt = 1 TO Len(sPacket) STEP 2
    ProcessReceivedChar(Val("&H" & Mid(sPacket, iCnt, 2)))
  NEXT
  bSimulate = FALSE

END

PUBLIC SUB RFXComTRX_Closed()

  Main.WriteDebugLog(("[RFXComTRX] ERROR: TCP socket closed by peer."))
  IF iConnectRetry < 6 THEN
    Main.WriteDebugLog(("[RFXComTRX] Retry to connect" & IIf(iConnectRetry, " in " & (iConnectDelay / 60) & " minutes.", ".")))
    tRFXComTRXConnect.Start
  ENDIF

END

PUBLIC SUB RFXComTRX_Error()

  DIM sString AS String = "[RFXComTRX] Transceiver: "

  ' handle error
  SELECT CASE hRFXComTRX.Status
    CASE Net.CannotCreateSocket
      Main.WriteLog(sString & ("THe system does not allow to create a socket."))
    CASE Net.HostNotFound
      Main.WriteLog(sString & ("Host '") & sTCPHost & ("' not found."))
    CASE Net.ConnectionRefused
      Main.WriteLog(sString & ("Unable to connect. Connection refused."))
    CASE Net.CannotRead
      Main.WriteLog(sString & ("Error reading data."))
    CASE Net.CannotWrite
      Main.WriteLog(sString & ("Error writing data."))
  END SELECT

END

PUBLIC SUB RFXComTRX_Read()

  DIM sData AS Byte

  TRY READ #hRFXComTRX, sData
  IF ERROR THEN Main.WriteDebugLog(("[RFXComTRX] Error reading data from the TCP port! -> ") & Error.Text)
  IF bSimulate = FALSE THEN ProcessReceivedChar(sData)

END

PRIVATE SUB ProcessReceivedChar(bTemp AS Byte)

  IF RecBytes = 0 THEN ' 1st char of a packet received
    IF bTemp <> 0 THEN
      IF bRFXComTRXDebug THEN Main.WriteDebugLog("[RFXComTRX] < ", 0)
    ELSE
      RETURN  ' ignore 1st char if 0
    ENDIF
  ENDIF

  TRY RecBuf[RecBytes] = bTemp ' store received char
  IF ERROR THEN
    RecBytes = 0 ' temp hack (overflow)
    RecBuf = NULL
    RETURN
  ENDIF
  INC RecBytes  ' increment char counter

  IF RecBytes > RecBuf[0] THEN ' all bytes of the packet received?
    IF bRFXComTRXDebug THEN Main.WriteDebugLog(Hex(bTemp, 2) & "\n", 1)
    Decode_Messages()  ' decode message
    RecBytes = 0  ' set to zero to receive next message
  ELSE
    IF bRFXComTRXDebug THEN Main.WriteDebugLog(Hex(bTemp, 2), 1) ' write the output to the screen
  ENDIF

END

PRIVATE SUB Decode_Messages()

  SELECT CASE RecBuf[1]
    CASE pTypeInterfaceMessage
      WriteMessage("Packettype        = Interface Message")
      Decode_InterfaceMessage()

    CASE pTypeRecXmitMessage
      WriteMessage("Packettype        = Receiver/Transmitter Message")
      Decode_RecXmitMessage()

    CASE pTypeUndecoded
      WriteMessage("Packettype        = Undecoded RF Message")
      Decode_UnDecoded()

    CASE pTypeLighting1
      WriteMessage("Packettype    = Lighting1")
      Decode_Lighting1()

    CASE pTypeLighting2
      WriteMessage("Packettype    = Lighting2")
      Decode_Lighting2()

    CASE pTypeLighting3
      WriteMessage("Packettype    = Lighting3")
      Decode_Lighting3()

    CASE pTypeLighting4
      WriteMessage("Packettype    = Lighting4")
      Decode_Lighting4()

    CASE pTypeLighting5
      WriteMessage("Packettype    = Lighting5")
      Decode_Lighting5()

    CASE pTypeSecurity1
      WriteMessage("Packettype    = Security1")
      Decode_Security1()

    CASE pTypeCamera1
      WriteMessage("Packettype    = Camera1")
      Decode_Camera1()

    CASE pTypeRemote
      WriteMessage("Packettype    = Remote control & IR")
      Decode_Remote()

    CASE pTypeThermostat1
      WriteMessage("Packettype    = Thermostat1")
      Decode_Thermostat1()

    CASE pTypeThermostat2
      WriteMessage("Packettype    = Thermostat2")
      Decode_Thermostat2()

    CASE pTypeThermostat3
      WriteMessage("Packettype    = Thermostat3")
      Decode_Thermostat3()

    CASE pTypeTEMP
      WriteMessage("Packettype    = TEMP")
      Decode_Temp()

    CASE pTypeHUM
      WriteMessage("Packettype    = HUM")
      Decode_Hum()

    CASE pTypeTEMP_HUM
      WriteMessage("Packettype    = TEMP_HUM")
      Decode_TempHum()

    CASE pTypeBARO
      WriteMessage("Packettype    = BARO")
      Decode_Baro()

    CASE pTypeTEMP_HUM_BARO
      WriteMessage("Packettype    = TEMP_HUM_BARO")
      Decode_TempHumBaro()

    CASE pTypeRAIN
      WriteMessage("Packettype    = RAIN")
      Decode_Rain()

    CASE pTypeWIND
      WriteMessage("Packettype    = WIND")
      Decode_Wind()

    CASE pTypeDT
      WriteMessage("Packettype    = DT")
      Decode_DateTime()

    CASE pTypeUV
      WriteMessage("Packettype    = UV")
      Decode_Uv()

    CASE pTypeCURRENT
      WriteMessage("Packettype    = CURRENT")
      Decode_Current()

    CASE pTypeENERGY
      WriteMessage("Packettype    = ENERGY")
      Decode_Energy()

    CASE pTypeGAS
      WriteMessage("Packettype    = GAS")
      Decode_Gas()

    CASE pTypeWATER
      WriteMessage("Packettype    = WATER")
      Decode_Water()

    CASE pTypeWEIGHT
      WriteMessage("Packettype    = WEIGHT")
      Decode_Weight()

    CASE pTypeRFXSensor
      WriteMessage("Packettype    = RFXSensor")
      Decode_RFXSensor()

    CASE pTypeRFXMeter
      WriteMessage("Packettype    = RFXMeter")
      Decode_RFXMeter()

    CASE ELSE
      WriteMessage("ERROR: Unknown Packet type: " & Hex(RecBuf[1], 2))
      RETURN
  END SELECT

END

PRIVATE SUB ConvertAddress(sAddr AS String) AS String

  DIM aAddress AS String[] = Split(sAddr, " ")

  IF bOldAddrFmt THEN
    RETURN UCase(aAddress[0] & "[" & Replace(aAddress[1], "0x", "") & "]")
  ELSE
    RETURN LCase(aAddress[0] & " 0x" & Hex(aAddress[1]))
  ENDIF

CATCH
  RETURN sAddr

END

PRIVATE SUB ConvertAddressSQL(sAddr AS String) AS String

  DIM aAddress AS String[] = Split(sAddr, " ")

  IF bOldAddrFmt THEN
    RETURN UCase(aAddress[0] & Replace(aAddress[1], "0x", ""))
  ELSE
    RETURN LCase(aAddress[0] & " 0x" & Hex(aAddress[1]))
  ENDIF

CATCH
  RETURN sAddr

END

' ENUM IRESPONSE AS Integer
'     packetlength = 0
'     packettype = 1
'     subtype = 2
'     seqnbr = 3
'     cmnd = 4
'     msg1 = 5
'     msg2 = 6
'     msg3 = 7
'     msg4 = 8
'     msg5 = 9
'     msg6 = 10
'     msg7 = 11
'     msg8 = 12
'     msg9 = 13
' END ENUM

PUBLIC SUB Decode_InterfaceMessage()

  SELECT CASE RecBuf[2]
    CASE sTypeInterfaceResponse
      WriteMessage("Subtype           = Interface Response")
      WriteMessage("Sequence no.      = " & CStr(RecBuf[3]))
      SELECT CASE RecBuf[4]
        CASE cmdSTATUS, cmdSETMODE, cmd310, cmd315, cmd830, cmd830F, cmd835, cmd835F, cmd895
          SELECT CASE RecBuf[4]
            CASE cmdSTATUS
              WriteMessage("Response on cmnd  = Get Status")
            CASE cmdSETMODE
              WriteMessage("Response on cmnd  = Set Mode")
            CASE cmd310
              WriteMessage("Response on cmnd  = Select 310MHz")
            CASE cmd315
              WriteMessage("Response on cmnd  = Select 315MHz")
            CASE cmd830
              WriteMessage("Response on cmnd  = Select 868.30MHz")
            CASE cmd830F
              WriteMessage("Response on cmnd  = Select 868.30MHz FSK")
            CASE cmd835
              WriteMessage("Response on cmnd  = Select 868.35MHz")
            CASE cmd835F
             WriteMessage("Response on cmnd  = Select 868.35MHz FSK")
            CASE cmd895
              WriteMessage("Response on cmnd  = Select 868.95MHz")
            CASE ELSE
              WriteMessage("Error: unknown response")
          END SELECT
          SELECT CASE RecBuf[5]
            CASE recType310
              WriteMessage("Transceiver type  = 310MHz")
            CASE recType315
              WriteMessage("Receiver type     = 315MHz")
            CASE recType43392
              WriteMessage("Transceiver type  = 433.92MHz")
            CASE recType86830
              WriteMessage("Receiver type     = 868.30MHz")
            CASE recType86830FSK
              WriteMessage("Receiver type     = 868.30MHz FSK")
            CASE recType86835
              WriteMessage("Receiver type     = 868.35MHz")
            CASE recType86835FSK
              WriteMessage("Receiver type     = 868.35MHz FSK")
            CASE recType86895
              WriteMessage("Receiver type     = 868.95MHz")
            CASE ELSE
              WriteMessage("Receiver type     = Unknown")
          END SELECT
          WriteMessage("Firmware version  = " & RecBuf[6])
          IF (RecBuf[7] AND &H80) <> 0 THEN
            WriteMessage("Undecoded         enabled")
          ELSE
            WriteMessage("Undecoded         disabled")
          ENDIF
          IF (RecBuf[9] AND &H1) <> 0 THEN
            WriteMessage("X10               enabled")
          ELSE
            WriteMessage("X10               disabled")
          ENDIF
          IF (RecBuf[9] AND &H2) <> 0 THEN
            WriteMessage("ARC               enabled")
          ELSE
            WriteMessage("ARC               disabled")
          ENDIF
          IF (RecBuf[9] AND &H4) <> 0 THEN
            WriteMessage("AC                enabled")
          ELSE
            WriteMessage("AC                disabled")
          ENDIF
          IF (RecBuf[9] AND &H8) <> 0 THEN
            WriteMessage("HomeEasy EU       enabled")
          ELSE
            WriteMessage("HomeEasy EU       disabled")
          ENDIF
          IF (RecBuf[9] AND &H10) <> 0 THEN
            WriteMessage("Ikea Koppla       enabled")
          ELSE
            WriteMessage("Ikea Koppla       disabled")
          ENDIF
          IF (RecBuf[9] AND &H20) <> 0 THEN
            WriteMessage("Oregon Scientific enabled")
          ELSE
            WriteMessage("Oregon Scientific disabled")
          ENDIF
          IF (RecBuf[9] AND &H40) <> 0 THEN
            WriteMessage("ATI               enabled")
          ELSE
            WriteMessage("ATI               disabled")
          ENDIF
          IF (RecBuf[9] AND &H80) <> 0 THEN
            WriteMessage("Visonic           enabled")
          ELSE
            WriteMessage("Visonic           disabled")
          ENDIF
          IF (RecBuf[8] AND &H1) <> 0 THEN
            WriteMessage("Mertik            enabled")
          ELSE
            WriteMessage("Mertik            disabled")
          ENDIF
          IF (RecBuf[8] AND &H2) <> 0 THEN
            WriteMessage("LightwaveRF       enabled")
          ELSE
            WriteMessage("LightwaveRF       disabled")
          ENDIF
          IF (RecBuf[8] AND &H4) <> 0 THEN
            WriteMessage("Hideki            enabled")
          ELSE
            WriteMessage("Hideki            disabled")
          ENDIF
          IF (RecBuf[8] AND &H8) <> 0 THEN
            WriteMessage("La Crosse         enabled")
          ELSE
            WriteMessage("La Crosse         disabled")
          ENDIF
          IF (RecBuf[8] AND &H10) <> 0 THEN
            WriteMessage("FS20              enabled")
          ELSE
            WriteMessage("FS20              disabled")
          ENDIF
          IF (RecBuf[8] AND &H20) <> 0 THEN
            WriteMessage("ProGuard          enabled")
          ELSE
            WriteMessage("ProGuard          disabled")
          ENDIF
          IF (RecBuf[8] AND &H40) <> 0 THEN
            WriteMessage("Novatys           enabled")
          ELSE
            WriteMessage("Novatys           disabled")
          ENDIF
          IF (RecBuf[8] AND &H80) <> 0 THEN
            WriteMessage("RFU protocol 7    enabled")
          ELSE
            WriteMessage("RFU protocol 7    disabled")
          ENDIF

        CASE cmdUNDECODED
          WriteMessage("Response on cmnd  = UnDecoded On")
        CASE cmdENABLEALL
          WriteMessage("Response on cmnd  = Enable All RF")
        CASE cmdSAVE
          WriteMessage("Response on cmnd  = Save")
        CASE cmdDISX10
          WriteMessage("Response on cmnd  = Disable X10 RF")
        CASE cmdDISARC
          WriteMessage("Response on cmnd  = Disable ARC RF")
        CASE cmdDISAC
          WriteMessage("Response on cmnd  = Disable AC RF")
        CASE cmdDISHEU
          WriteMessage("Response on cmnd  = Disable HomeEasy EU RF")
        CASE cmdDISKOP
          WriteMessage("Response on cmnd  = Disable Ikea Koppla RF")
        CASE cmdDISOREGON
          WriteMessage("Response on cmnd  = Disable Oregon Scientific RF")
        CASE cmdDISATI
          WriteMessage("Response on cmnd  = Disable ATI remote RF")
        CASE cmdDISVISONIC
          WriteMessage("Response on cmnd  = Disable Visonic RF")
        CASE cmdDISMERTIK
          WriteMessage("Response on cmnd  = Disable Mertik RF")
        CASE cmdDISAD
          WriteMessage("Response on cmnd  = Disable AD RF")
        CASE cmdDISHID
          WriteMessage("Response on cmnd  = Disable Hideki RF")
        CASE cmdDISLCROS
          WriteMessage("Response on cmnd  = Disable La Crosse RF")
        CASE cmdDISFS20
          WriteMessage("Response on cmnd  = Disable FS20 RF")
        CASE cmdDISNOVAT
          WriteMessage("Response on cmnd  = Disable Novatys RF")
        CASE ELSE
          WriteMessage("ERROR: Unexpected response for Packet type=" & Hex(RecBuf[1]) & ", Sub type=" & Hex(RecBuf[2]) & " msg=" & Hex(RecBuf[4]))
          RETURN
    END SELECT
  END SELECT

END

' ENUM ICMD AS Integer
'        packetlength = 0
'        packettype = 1
'        subtype = 2
'        seqnbr = 3
'        cmnd = 4
'        msg1 = 5
'        msg2 = 6
'        msg3 = 7
'        msg4 = 8
'        msg5 = 9
'        msg6 = 10
'        msg7 = 11
'        msg8 = 12
'        msg9 = 13
'        size = 13

' ENUM UNDECODED AS Integer
'     packetlength = 0
'     packettype = 1
'     subtype = 2
'     seqnbr = 3
'     msg1 = 4
'     msg2 to msg32 depending on RF packet length
'     size = 36 ' maximum size
'     pType = &H3
'     sTypeUac = &H0
'     sTypeUarc = &H1
'     sTypeUati = &H2
'     sTypeUhideki = &H3
'     sTypeUlacrosse = &H4
'     sTypeUlwrf = &H5
'     sTypeUmertik = &H6
'     sTypeUoregon1 = &H7
'     sTypeUoregon2 = &H8
'     sTypeUoregon3 = &H9
'     sTypeUproguard = &HA
'     sTypeUvisonic = &HB
'     sTypeUnec = &HC
'     sTypeUfs20 = &HD
' END ENUM

PUBLIC SUB Decode_UnDecoded()

  DIM iCnt AS Integer

  WriteMessage("UnDecoded ", FALSE)
  SELECT CASE RecBuf[2]
    CASE sTypeUac
      WriteMessage("AC:", FALSE)
    CASE sTypeUarc
      WriteMessage("ARC:", FALSE)
    CASE sTypeUati
      WriteMessage("ATI:", FALSE)
    CASE sTypeUhideki
      WriteMessage("HIDEKI:", FALSE)
    CASE sTypeUlacrosse
      WriteMessage("LACROSSE:", FALSE)
    CASE sTypeUlwrf
      WriteMessage("LWRF:", FALSE)
    CASE sTypeUmertik
      WriteMessage("MERTIK:", FALSE)
    CASE sTypeUoregon1
      WriteMessage("OREGON1:", FALSE)
    CASE sTypeUoregon2
      WriteMessage("OREGON2:", FALSE)
    CASE sTypeUoregon3
      WriteMessage("OREGON3:", FALSE)
    CASE sTypeUproguard
      WriteMessage("PROGUARD:", FALSE)
    CASE sTypeUvisonic
      WriteMessage("VISONIC:", FALSE)
    CASE sTypeUnec
      WriteMessage("NEC:", FALSE)
    CASE sTypeUfs20
      WriteMessage("FS20:", FALSE)
    CASE ELSE
      WriteMessage("ERROR: Unknown Sub type for Packet type=" & Hex(RecBuf[1]) & ": " & Hex(RecBuf[2]))
  END SELECT
  FOR iCnt = 0 TO RecBuf[0] - RecBuf[4]
    WriteMessage(Hex(RecBuf[RecBuf[4] + iCnt]), FALSE)
  NEXT
  WriteMessage(" ")

END

' ENUM LIGHTING1 AS Integer
'     packetlength = 0
'     packettype = 1
'     subtype = 2
'     seqnbr = 3
'     housecode = 4
'     unitcode = 5
'     cmnd = 6
'     filler = 7 'bits 3-0
'     rssi = 7   'bits 7-4
'     size = 7
' END ENUM

PUBLIC SUB Decode_Lighting1()

  DIM sAddress, sType, sCmd, sMessage AS String

  SELECT CASE RecBuf[2]
    CASE sTypeX10
      sType = "X10"
      WriteMessage("Subtype       = X10")
      WriteMessage("Sequence no.  = " & CStr(RecBuf[3]))
      WriteMessage("Housecode     = " & Chr(RecBuf[4]))
      WriteMessage("Unitcode      = " & CStr(RecBuf[5]))
      sAddress = Chr(RecBuf[4]) & Format(CStr(RecBuf[5]), "00")
      SELECT CASE RecBuf[6]
        CASE &H0
          sCmd = "Off"
        CASE &H1
          sCmd = "On"
        CASE &H2
          sCmd = "Dim"
        CASE &H3
          sCmd = "Bright"
        CASE &H5
          sCmd = "All On"
        CASE &H6
          sCmd = "All Off"
        CASE ELSE
		  sCmd = "Unknown"
          WriteMessage("Command       = Unknown")
          RETURN
      END SELECT
      WriteMessage("Command       = " & sCmd)
    CASE sTypeARC
      sType = "ARC"
      WriteMessage("Subtype       = ARC")
      WriteMessage("Sequence no.  = " & CStr(RecBuf[3]))
      WriteMessage("Housecode     = " & Chr(RecBuf[4]))
      WriteMessage("Unitcode      = " & CStr(RecBuf[5]))
      sAddress = Chr(RecBuf[4]) & Format(CStr(RecBuf[5]), "00")
      SELECT CASE RecBuf[6]
        CASE &H0
          sCmd = "Off"
        CASE &H1
          sCmd = "On"
        CASE &H5
          sCmd = "All On"
        CASE &H6
          sCmd = "All Off"
        CASE ELSE
		  sCmd &= "Unknown"
          WriteMessage("Command       = Unknown")
          RETURN
      END SELECT
      WriteMessage("Command       = " & sCmd)
    CASE sTypeAB400D
      sType = "AB400"
      WriteMessage("Subtype       = ELRO AB400")
      WriteMessage("Sequence no.  = " & CStr(RecBuf[3]))
      WriteMessage("Housecode     = " & Chr(RecBuf[4]))
      WriteMessage("Unitcode      = " & CStr(RecBuf[5]))
      sAddress = Chr(RecBuf[4]) & Format(CStr(RecBuf[5]), "00")
      SELECT CASE RecBuf[6]
        CASE &H0
          sCmd = "Off"
        CASE &H1
          sCmd = "On"
        CASE ELSE
		  sCmd = "Unknown"
          WriteMessage("Command       = Unknown")
          RETURN
      END SELECT
      WriteMessage("Command       = " & sCmd)
    CASE ELSE
      WriteMessage("ERROR: Unknown Sub type for Packet type=" & Hex(RecBuf[1]) & ": " & Hex(RecBuf[2]))
      RETURN
  END SELECT
  sMessage = sType & " " & sAddress & " " & sCmd & " "
  sMessage &= CStr(Lsr(RecBuf[7], 4))
  WriteMessage("Signal level  = " & CStr(Lsr(RecBuf[7], 4)))

  Main.WriteLog(sMessage)
  Main.BroadcastEvent(sMessage, iTCPPort)
  
END

' ENUM LIGHTING2 AS Integer
'     packetlength = 0
'     packettype = 1
'     subtype = 2
'     seqnbr = 3
'     id1 = 4
'     id2 = 5
'     id3 = 6
'     id4 = 7
'     unitcode = 8
'     cmnd = 9
'     level = 10
'     filler = 11 'bits 3-0
'     rssi = 11   'bits 7-4
'     size = 11
' END ENUM

PUBLIC SUB Decode_Lighting2()

  DIM sAddress, sType, sCmd, sMessage AS String

  SELECT CASE RecBuf[2]
    CASE sTypeAC, sTypeHEU, sTypeANSLUT
      SELECT CASE RecBuf[2]
        CASE sTypeAC
          sType = "AC"
          WriteMessage("Subtype       = AC")
        CASE sTypeHEU
          sType = "HEEU"
          WriteMessage("Subtype       = HomeEasy EU")
        CASE sTypeANSLUT
          sType = "Anslut"
          WriteMessage("Subtype       = ANSLUT")
      END SELECT
      WriteMessage("Sequence no.  = " & CStr(RecBuf[3]))
      sAddress = Hex(RecBuf[4]) & Hex(RecBuf[5], 2) & Hex(RecBuf[6], 2) & Hex(RecBuf[7], 2) & " " & CStr(RecBuf[8])
	  WriteMessage("ID            = " & sAddress)
      SELECT CASE RecBuf[9]
        CASE &H0
          sCmd = "Off"
        CASE &H1
          sCmd = "On"
        CASE &H2
          sCmd = "Dim " & CStr(RecBuf[10])
        CASE &H3
          sCmd = "Group Off"
        CASE &H4
          sCmd = "Group On"
        CASE &H5
          sCmd = "Dim " & CStr(RecBuf[10])
          WriteMessage("Command       = Group " & sCmd)
        CASE ELSE
		  sCmd= "Unknown"
          WriteMessage("Command       = Unknown")
          RETURN
      END SELECT
      WriteMessage("Command       = " & sCmd)
    CASE ELSE
      WriteMessage("ERROR: Unknown Sub type for Packet type=" & Hex(RecBuf[1]) & ": " & Hex(RecBuf[2]))
      RETURN
  END SELECT
  sMessage = sType & " " & sAddress & " " & sCmd & " "
  sMessage &= CStr(Lsr(RecBuf[11], 4))
  WriteMessage("Signal level  = " & CStr(Lsr(RecBuf[11], 4)))

  Main.WriteLog(sMessage)
  Main.BroadcastEvent(sMessage, iTCPPort)
  
END

' ENUM LIGHTING3 AS Integer
'     packetlength = 0
'     packettype = 1
'     subtype = 2
'     seqnbr = 3
'     system = 4
'     channel = 5
'     cmnd = 6
'     level = 7
'     filler = 8  'bits 3-0
'     rssi = 8    'bits 7-4
'     size = 8
' END ENUM

PUBLIC SUB Decode_Lighting3()

  Main.WriteDebugLog("Decode Lighting3 Not implemented")

END

' ENUM LIGHTING4 AS Integer
'     packetlength = 0
'     packettype = 1
'     subtype = 2
'     seqnbr = 3
'     cmd1 = 4
'     cmd2 = 5
'     cmd3 = 6
'     pulsehigh = 7
'     pulselow = 8
'     filler = 9
'     size = 9
' END ENUM

PUBLIC SUB Decode_Lighting4()

  Main.WriteDebugLog("Decode Lighting4 Not implemented")

END

' ENUM LIGHTING5 AS Integer
'     packetlength = 0
'     packettype = 1
'     subtype = 2
'     seqnbr = 3
'     id1 = 4
'     id2 = 5
'     id3 = 6
'     unitcode = 7
'     cmnd = 8
'     filler = 9 'bits 3-0
'     rssi = 9   'bits 7-4
'     size = 9
' END ENUM

PUBLIC SUB Decode_Lighting5()

  Main.WriteDebugLog("Decode Lighting5 Not implemented")


END

' ENUM SECURITY1 AS Integer
'      packetlength = 0
'      packettype = 1
'      subtype = 2
'      seqnbr = 3
'      id1 = 4
'      id2 = 5
'      id3 = 6
'      status = 7
'      battery_level = 8  'bits 3-0
'      rssi = 8           'bits 7-4
'      filler = 8
'      size = 8
'  END ENUM

PUBLIC SUB Decode_Security1()

  DIM sAddress, sType, sCmd, sMessage AS String
  DIM sTamper AS String = " "
  DIM sBatt AS String = "OK"

  SELECT CASE RecBuf[2]
    CASE sTypeSecX10
      sType = "X10Security"
      WriteMessage("Subtype       = X10 security")
    CASE sTypeSecX10M
      sType = "X10Security"
      WriteMessage("Subtype       = X10 security motion")
    CASE sTypeSecX10R
      sType = "X10Security"
      WriteMessage("Subtype       = X10 security remote")
    CASE sTypeKD101
	  sType = "KD101 Smoke"
      WriteMessage("Subtype       = KD101 smoke detector")
    CASE sTypePowercodeSensor
      sType = "VisonicSensor"
      WriteMessage("Subtype       = Visonic PowerCode sensor - primary contact")
    CASE sTypePowercodeMotion
      sType = "VisonicMotion"
      WriteMessage("Subtype       = Visonic PowerCode motion")
    CASE sTypeCodesecure
      sType = "VisonicCode"
      WriteMessage("Subtype       = Visonic CodeSecure")
    CASE sTypePowercodeAux
      sType = "VisonicPwrCode"
      WriteMessage("Subtype       = Visonic PowerCode sensor - auxiliary contact")
    CASE ELSE
	  sType = "Unknown"
      WriteMessage("ERROR: Unknown Sub type for Packet type=" & Hex(RecBuf[1]) & ": " & Hex(RecBuf[2]))
      RETURN
  END SELECT
  WriteMessage("Sequence no.  = " & CStr(RecBuf[3]))
  sAddress = ConvertAddress("x10sec " & Hex(RecBuf[4], 2) & Hex(RecBuf[5], 2) & Hex(RecBuf[6], 2))
  WriteMessage("ID1-3         = " & sAddress)

  SELECT CASE RecBuf[7]
    CASE sStatusNormal
      sCmd = "Normal"
    CASE sStatusNormalDelayed
      sCmd = "Normal Delayed"
    CASE sStatusAlarm
      sCmd = "Alarm"
    CASE sStatusAlarmDelayed
      sCmd = "Alarm Delayed"
    CASE sStatusMotion
      sCmd = "Motion"
    CASE sStatusNoMotion
      sCmd = "No Motion"
    CASE sStatusPanic
      sCmd = "Panic"
    CASE sStatusPanicOff
      sCmd = "Panic End"
    CASE sStatusTamper
      sTamper = "Tamper"
    CASE sStatusArmAway
      sCmd = "Arm Away"
    CASE sStatusArmAwayDelayed
      sCmd = "Arm Away Delayed"
    CASE sStatusArmHome
      sCmd = "Arm Home"
    CASE sStatusArmHomeDelayed
      sCmd = "Arm Home Delayed"
    CASE sStatusDisarm
      sCmd = "Disarm"
    CASE sStatusLightOff
      sCmd = "Light Off"
    CASE sStatusLightOn
      sCmd = "Light On"
    CASE sStatusLight2Off
      sCmd = "Light 2 Off"
    CASE sStatusLight2On
      sCmd = "Light 2 On"
    CASE sStatusDark
      sCmd = "Dark"
    CASE sStatusLight
      sCmd = "Light"
    CASE sStatusBatLow
      sCmd = "Battery low MS10 or XX18 sensor"
      sBatt = "Low"
    CASE sStatusPairKD101
      sCmd = "Pair KD101"
  END SELECT
  WriteMessage("Status        = " & sCmd)
  IF (RecBuf[8] AND &HF) = 0 THEN
    sBatt = "Low"
  ELSE
    sBatt = "OK"
  ENDIF
  WriteMessage("Battery level = " & sBatt)
  sMessage = sAddress & " " & sCmd & " " & sBatt & " "
  sMessage &= CStr(Lsr(RecBuf[8], 4))
  WriteMessage("Signal level  = " & CStr(Lsr(RecBuf[8], 4)))

  Main.WriteLog(sMessage)
  Main.BroadcastEvent(sMessage, iTCPPort)

END

' ENUM CAMERA1 AS Integer
'     packetlength = 0
'     packettype = 1
'     subtype = 2
'     seqnbr = 3
'     housecode = 4
'     cmnd = 5
'     filler = 6 'bits 3-0
'     rssi = 6   'bits 7-4
'     size = 6
' END ENUM

PUBLIC SUB Decode_Camera1()

  Main.WriteDebugLog("Decode Camera1 Not implemented")

END

' ENUM REMOTE AS Integer
'      packetlength = 0
'      packettype = 1
'      subtype = 2
'      seqnbr = 3
'      id = 4
'      cmnd = 5
'      toggle = 6       'bit 0 
'      filler = 6       'bits 3-1 
'      rssi = 6         'bits 7-4 
'      size = 6
'  END ENUM

PUBLIC SUB Decode_Remote()

  Main.WriteDebugLog("Decode Remote Not implemented")

END

' ENUM THERMOSTAT1 AS Integer
'     packetlength = 0
'     packettype = 1
'     subtype = 2
'     seqnbr = 3
'     id1 = 4
'     id2 = 5
'     temperature = 6
'     set_point = 7
'     status = 8  'bits 1-0
'     filler = 8  'bits 6-2
'     mode = 8    'bit 7
'     battery_level = 9   'bits 3-0
'     rssi = 9            'bits 7-4
'     size = 9
' END ENUM

PUBLIC SUB Decode_Thermostat1()

  Main.WriteDebugLog("Decode Thermostat1 Not implemented")

END

' ENUM THERMOSTAT2 AS Integer
'     packetlength = 0
'     packettype = 1
'     subtype = 2
'     seqnbr = 3
'     unitcode = 4
'     cmnd = 5
'     filler = 6  'bits 3-0
'     rssi = 6    'bits 7-4
'     size = 6
' END ENUM

PUBLIC SUB Decode_Thermostat2()

  Main.WriteDebugLog("Decode Thermostat2 Not implemented")

END

' ENUM THERMOSTAT3 AS Integer
'     packetlength = 0
'     packettype = 1
'     subtype = 2
'     seqnbr = 3
'     unitcode1 = 4
'     unitcode2 = 5
'     unitcode3 = 6
'     cmnd = 7
'     filler = 9   'bits 3-0
'     rssi = 9     'bits 7-4
'     size = 9
' END ENUM

PUBLIC SUB Decode_Thermostat3()

  Main.WriteDebugLog("Decode Thermostat3 Not implemented")

END

' ENUM RAIN AS Integer
'     packetlength = 0
'     packettype = 1
'     subtype = 2
'     seqnbr = 3
'     id1 = 4
'     id2 = 5
'     rainrateh = 6
'     rainratel = 7
'     raintotal1 = 8
'     raintotal2 = 9
'     raintotal3 = 10
'     battery_level = 11  'bits 3-0
'     rssi = 11           'bits 7-4
'     size = 11
' END ENUM

PRIVATE SUB Decode_Rain()

  Main.WriteDebugLog("Decode Rain Not implemented")

END

' ENUM Temp AS Integer
'     packetlength = 0
'     packettype = 1
'     subtype = 2
'     seqnbr = 3
'     id1 = 4
'     id2 = 5
'     temperatureh = 6    'bits 6-0
'     tempsign = 6        'bit 7
'     temperaturel = 7
'     battery_level = 8   'bits 3-0
'     rssi = 8            'bits 7-4
'     size = 8
' END ENUM

PUBLIC SUB Decode_Temp()

  DIM sAddress, sType, sTemp, sBatt, sMessage AS String

  SELECT CASE RecBuf[2]
    CASE sTypeTEMP1
      sType = "TEMP1"
      WriteMessage("Subtype       = TEMP1 - THR128/138, THC138")
    CASE sTypeTEMP2
      sType = "TEMP2"
      WriteMessage("Subtype       = TEMP2 - THC238/268,THN132,THWR288,THRN122,THN122,AW129/131")
    CASE sTypeTEMP3
      sType = "TEMP3"
      WriteMessage("Subtype       = TEMP3 - THWR800")
    CASE sTypeTEMP4
      sType = "TEMP4"
      WriteMessage("Subtype       = TEMP4 - RTHN318")
    CASE sTypeTEMP5
      sType = "TEMP5"
      WriteMessage("Subtype       = TEMP5 - LaCrosse TX3, TX4, TX17")
    CASE ELSE
	  sType = "Unknown"
      WriteMessage("ERROR: Unknown Sub type for Packet type=" & Hex(RecBuf[1]) & ":" & Hex(RecBuf[2]))
      RETURN
  END SELECT
  sAddress = ConvertAddress(sType & " " & (RecBuf[4] * 256 + RecBuf[5]))
  WriteMessage("Sequence no.  = " & CStr(RecBuf[3]))
  WriteMessage("ID            = " & sAddress)
  IF (RecBuf[6] AND &H80) = 0 THEN
    sTemp = Format(CStr((RecBuf[6] * 256 + RecBuf[7]) / 10), "00.0")
  ELSE
    sTemp = "-" & Format(CStr(((RecBuf[6] AND &H7F) * 256 + RecBuf[7]) / 10), "00.0")
  ENDIF
  WriteMessage("Temperature   = " & sTemp & " Â°C")
  
  IF (RecBuf[8] AND &HF) = 0 THEN
    sBatt = "Low"
  ELSE
    sBatt = "OK"
  ENDIF
  WriteMessage("Battery       = OK")

  sMessage = sAddress & " " & sTemp & " " & sBatt & " "
  sMessage &= CStr(Lsr(RecBuf[8], 4)) & " "
  WriteMessage("Signal level  = " & CStr(Lsr(RecBuf[8], 4)))
  
  Main.WriteLog(sMessage)
  Main.BroadcastEvent(sMessage, iTCPPort)
  
END

' ENUM TEMP_HUM AS Integer
'      packetlength = 0
'      packettype = 1
'      subtype = 2
'      seqnbr = 3
'      id1 = 4
'      id2 = 5
'      humidity = 6
'      humidity_status = 7
'      battery_level = 8  'bits 3-0
'      rssi = 8           'bits 7-4
'      size = 8
'  END ENUM

PUBLIC SUB Decode_Hum()

  Main.WriteDebugLog("Decode Hum Not implemented")

END

' ENUM TEMP_HUM AS Integer
'     packetlength = 0
'     packettype = 1
'     subtype = 2
'     seqnbr = 3
'     id1 = 4
'     id2 = 5
'     temperatureh = 6    'bits 6-0
'     tempsign = 6        'bit 7
'     temperaturel = 7
'     humidity = 8
'     humidity_status = 9
'     battery_level = 10  'bits 3-0
'     rssi = 10           'bits 7-4
'     size = 10
' END ENUM

PRIVATE SUB Decode_TempHum()

  DIM sAddress, sType, sBatt, sTemp, sHumid, sComfort, sMessage AS String

  SELECT CASE RecBuf[2]
    CASE sTypeTH1
      WriteMessage("Subtype       = TH1 - THGN122/123/132,THGR122/228/238/268")
      sType = "TH1"
    CASE sTypeTH2
      WriteMessage("Subtype       = TH2 - THGR810")
      sType = "TH2"
    CASE sTypeTH3
      WriteMessage("Subtype       = TH3 - RTGR328")
      sType = "TH3"
    CASE sTypeTH4
      WriteMessage("Subtype       = TH4 - THGR328")
      sType = "TH4"
    CASE sTypeTH5
      WriteMessage("Subtype       = TH5 - WTGR800")
      sType = "TH5"
    CASE sTypeTH6
      WriteMessage("Subtype       = TH6 - THGR918,THGRN228,THGN500")
      sType = "TH6"
    CASE sTypeTH7
      WriteMessage("Subtype       = TH7 - TFA TS34C")
      sType = "TH7"
    CASE sTypeTH8
      WriteMessage("Subtype       = TH8 - ESIC WT440H/450H")
      sType = "TH8"
    CASE ELSE
      WriteMessage("ERROR: Unknown Sub type for Packet type=" & Hex(RecBuf[1]) & ":" & Hex(RecBuf[2]))
      RETURN
  END SELECT
  WriteMessage("Sequence no.  = " & RecBuf[3])
  sAddress = ConvertAddress(sType & " " & (RecBuf[4] * 256 + RecBuf[5]))
  WriteMessage("ID            = " & sAddress)
  IF (RecBuf[6] AND &H80) = 0 THEN
    sTemp = Format(CStr((RecBuf[6] * 256 + RecBuf[7]) / 10), "00.0")
  ELSE
    sTemp = "-" & Format(CStr(((RecBuf[6] AND &H7F) * 256 + RecBuf[7]) / 10), "00.0")
  ENDIF
  WriteMessage("Temperature   = " & sTemp & "Â°C")
  sHumid = RecBuf[8]
  WriteMessage("Humidity      = " & sHumid & " %")
  SELECT CASE RecBuf[9]
    CASE &H0
      sComfort = "Dry"
    CASE &H1
      sComfort = "Comfort"
    CASE &H2
      sComfort = "Normal"
    CASE &H3
      sComfort = "Wet"
  END SELECT
  WriteMessage("Status        = " & sComfort)
 
  IF RecBuf[2] = sTypeTH6 THEN
    sBatt = (RecBuf[10] * 10) + 10
  ELSE
    IF (RecBuf[10] AND &HF) = 0 THEN
      sBatt = "Low"
    ELSE
      sBatt = "OK"
    ENDIF
  ENDIF
  WriteMessage("Battery       = " & sBatt)
  
  sMessage = sAddress & " " & sTemp & " "  & sHumid & " " & sComfort & " " & sBatt & " "
  sMessage &= Lsr(RecBuf[10], 4) & " "
  WriteMessage("Signal level  = " & Lsr(RecBuf[10], 4))

  Main.WriteLog(sMessage)
  Main.BroadcastEvent(sMessage, iTCPPort)

END

' ENUM TEMP_HUM_BARO AS Integer
'     packetlength = 0
'     packettype = 1
'     subtype = 2
'     seqnbr = 3
'     id1 = 4
'     id2 = 5
'     temperatureh = 6    'bits 6-0
'     tempsign = 6        'bit 7
'     temperaturel = 7
'     humidity = 8
'     humidity_status = 9
'     baroh = 10
'     barol = 11
'     forecast = 12
'     battery_level = 13  'bits 3-0
'     rssi = 13           'bits 7-4
'     size = 13
' END ENUM

PUBLIC SUB Decode_TempHumBaro()

  DIM sAddress, sType, sBatt, sTemp, sHumid, sComfort, sComfBuf, sBaro, sForecast, sMessage AS String
  DIM iBatt AS Integer

  SELECT CASE RecBuf[2]
    CASE sTypeTH1
      sType = "THB1"
      WriteMessage("Subtype       = THB1 - BTHR918")
    CASE sTypeTH2
      sType = "THB2"
      WriteMessage("Subtype       = THB2 - BTHR918N, BTHR968")
    CASE ELSE
	  sType = "Unknown"
      WriteMessage("ERROR: Unknown Sub type for Packet type=" & Hex(RecBuf[1]) & ":" & Hex(RecBuf[2]))
      RETURN
  END SELECT
  WriteMessage("Sequence no.  = " & CStr(RecBuf[3]))
  sAddress = ConvertAddress(sType & " " & (RecBuf[4] * 256 + RecBuf[5]))
  WriteMessage("ID            = " & sAddress)
  IF (RecBuf[6] AND &H80) = 0 THEN
    sTemp = Format(CStr((RecBuf[6] * 256 + RecBuf[7]) / 10), "00.0")
    WriteMessage("Temperature   = " & sTemp & " Â°C")
  ELSE
    sTemp = "-" & Format(CStr((RecBuf[6] * 256 + RecBuf[7]) / 10), "00.0")
    WriteMessage("Temperature   = " & sTemp & " Â°C")
  ENDIF
  sHumid = CStr(RecBuf[8])
  WriteMessage("Humidity      = " & sHumid & " %")
  SELECT CASE RecBuf[9]
    CASE &H0
      sComfort = "Status        = Dry"
	  sComfBuf = "Dry"
    CASE &H1
      sComfort = "Status        = Comfort"
	  sComfBuf = "Comfort"
    CASE &H2
      sComfort = "Status        = Normal"
	  sComfBuf = "Normal"
    CASE &H3
      sComfort = "Status        = Wet"
	  sComfBuf = "Wet"
  END SELECT

  sBaro = CStr(RecBuf[10] * 256 + RecBuf[11])
  WriteMessage("Barometer     = " & sBaro)
  SELECT CASE RecBuf[12]
    CASE &H0
      sForecast = "No Info Avail"
    CASE &H1
      sForecast = "Sunny"
    CASE &H2
      sForecast = "Partly Cloudy"
    CASE &H3
      sForecast = "Cloudy"
    CASE &H4
      sForecast = "Rain"
  END SELECT
  WriteMessage("Forecast      = " & sForecast)
  WriteMessage("Signal level  = " & CStr(Lsr(RecBuf[13], 4)))
  IF (RecBuf[13] AND &HF) = 0 THEN
    sBatt = "Low"
	iBatt = 0
  ELSE
    sBatt = "OK"
	iBatt = 1
  ENDIF
  WriteMessage("Battery       = " & sBatt)

  sMessage = sAddress & " " & sTemp & " "  & Format(sHumid, "000") & " " & sComfBuf & " " & Format(sBaro, "0000") & " "  & sForecast & " " & sBatt & " "
  sMessage &= Lsr(RecBuf[13], 4) & " "
  WriteMessage("Signal level  = " & Lsr(RecBuf[13], 4))

  Main.WriteLog(sMessage)
  Main.BroadcastEvent(sMessage, iTCPPort)
  
  IF Main.bMySQLEnabled AND sAddress = "THB2[50176]" THEN TRY Main.hDB.Exec("INSERT INTO tblTHB2_50176 (TimeStamp, Temp, Humidity, Baro, Battery) VALUES (&1, &2, &3, &4, &5)", Now(), sTemp, sHumid, sBaro, iBatt)

  END

' ENUM UV AS Integer
'     packetlength = 0
'     packettype = 1
'     subtype = 2
'     seqnbr = 3
'     id1 = 4
'     id2 = 5
'     uv = 6
'     temperatureh = 7    'bits 6-0
'     tempsign = 7        'bit 7
'     temperaturel = 8
'     battery_level = 9   'bits 3-0
'     rssi = 9            'bits 7-4
'     size = 9
' END ENUM

PUBLIC SUB Decode_Uv()

  Main.WriteDebugLog("Decode UV Not implemented")

END

PUBLIC SUB Decode_Baro()

  Main.WriteDebugLog("Decode Baro Not implemented")

END

PRIVATE SUB WriteMessage(sText AS String, OPTIONAL bNoReturn AS Boolean)

  IF bRFXComTRXDebug THEN
    IF bNoReturn THEN
      Main.WriteDebugLog(sText, TRUE)
    ELSE
      Main.WriteDebugLog("[RFXComTRX] " & sText)
    ENDIF
  ENDIF

END

' ENUM WIND AS Integer
'     packetlength = 0
'     packettype = 1
'     subtype = 2
'     seqnbr = 3
'     id1 = 4
'     id2 = 5
'     directionh = 6
'     directionl = 7
'     av_speedh = 8
'     av_speedl = 9
'     gusth = 10
'     gustl = 11
'     temperatureh = 12   'bits 6-0
'     tempsign = 12       'bit 7
'     temperaturel = 13
'     chillh = 14         'bits 6-0
'     chillsign = 14      'bit 7
'     chilll = 15
'     battery_level = 16  'bits 3-0
'     rssi = 16           'bits 7-4
'     size = 16
' END ENUM

PUBLIC SUB Decode_Wind()

  Main.WriteDebugLog("Decode Wind Not implemented")

END

PRIVATE SUB WindDirection(sDirection AS String) AS String

  Main.WriteDebugLog("Decode WindDirection Not implemented")

END

' ENUM DT AS Integer
'     packetlength = 0
'     packettype = 1
'     subtype = 2
'     seqnbr = 3
'     id1 = 4
'     id2 = 5
'     yy = 6
'     mm = 7
'     dd = 8
'     dow = 9
'     hr = 10
'     Min = 11
'     sec = 12
'     battery_level = 13  'bits 3-0
'     rssi = 13           'bits 7-4
'     size = 13
' END ENUM

PUBLIC SUB Decode_DateTime()

  Main.WriteDebugLog("Decode DateTime Not implemented")

END

' ENUM CURRENT AS Integer
'     packetlength = 0
'     packettype = 1
'     subtype = 2
'     seqnbr = 3
'     id1 = 4
'     id2 = 5
'     count = 6
'     ch1h = 7
'     ch1l = 8
'     ch2h = 9
'     ch2l = 10
'     ch3h = 11
'     ch3l = 12
'     battery_level = 13  'bits 3-0
'     rssi = 13           'bits 7-4
'     size = 13
' END ENUM

PUBLIC SUB Decode_Current()

  Main.WriteDebugLog("Decode Current Not implemented")

END

' ENUM ENERGY AS Integer
'     packetlength = 0
'     packettype = 1
'     subtype = 2
'     seqnbr = 3
'     id1 = 4
'     id2 = 5
'     count = 6
'     instant1 = 7
'     instant2 = 8
'     instant3 = 9
'     instant4 = 10
'     total1 = 11
'     total2 = 12
'     total3 = 13
'     total4 = 14
'     total5 = 15
'     total6 = 16
'     battery_level = 17  'bits 3-0
'     rssi = 17           'bits 7-4
'     size = 17
' END ENUM

PUBLIC SUB Decode_Energy()

  Main.WriteDebugLog("Decode Energy Not implemented")

END

PUBLIC SUB Decode_Gas()

  Main.WriteDebugLog("Decode Gas Not implemented")

END

PUBLIC SUB Decode_Water()

  Main.WriteDebugLog("Decode Water Not implemented")

END

' ENUM WEIGHT AS Integer
'     packetlength = 0
'     packettype = 1
'     subtype = 2
'     seqnbr = 3
'     id1 = 4
'     id2 = 5
'     weighthigh = 6
'     weightlow = 7
'     filler = 8   'bits 3-0
'     rssi = 8            'bits 7-4
'     size = 8
' END ENUM

PUBLIC SUB Decode_Weight()

  Main.WriteDebugLog("Decode Weight Not implemented")

END

' ENUM RFXSENSOR AS Integer
'     packetlength = 0
'     packettype = 1
'     subtype = 2
'     seqnbr = 3
'     id = 4
'     msg1 = 5
'     msg2 = 6
'     filler = 7  'bits 3-0
'     rssi = 7    'bits 7-4
'     size = 7
' END ENUM

PUBLIC SUB Decode_RFXSensor()

  Main.WriteDebugLog("Decode RFXSensor Not implemented")

END

' ENUM RFXMETER AS Integer
'     packetlength = 0
'     packettype = 1
'     subtype = 2
'     seqnbr = 3
'     id1 = 4
'     id2 = 5
'     count1 = 6
'     count2 = 7
'     count3 = 8
'     count4 = 9
'     filler = 10 'bits 3-0
'     rssi = 10   'bits 7-4
'     size = 10
' END ENUM

PRIVATE SUB Decode_RFXMeter()

  Main.WriteDebugLog("Decode RFXMeter Not implemented")

END

' ENUM LIGHTING1 AS Integer
'     packetlength = 0
'     packettype = 1
'     subtype = 2
'     seqnbr = 3
'     housecode = 4
'     unitcode = 5
'     cmnd = 6
'     filler = 7 'bits 3-0
'     rssi = 7   'bits 7-4
'     size = 7
' END ENUM

' Lighting1
PUBLIC SUB Lighting1(sType AS String, sAddress AS String, sCommand AS String, OPTIONAL bGroup AS Boolean)

  Main.WriteDebugLog("Send Lighting1 Not implemented")

END

' ENUM LIGHTING2 AS Integer
'     packetlength = 0
'     packettype = 1
'     subtype = 2
'     seqnbr = 3
'     id1 = 4
'     id2 = 5
'     id3 = 6
'     id4 = 7
'     unitcode = 8
'     cmnd = 9
'     level = 10
'     filler = 11 'bits 3-0
'     rssi = 11   'bits 7-4
'     size = 11
' 
'     pType = &H11
'     sTypeAC = &H0
'     sTypeHEU = &H1
'     sTypeANSLUT = &H2
' END ENUM

' Lighting2
PUBLIC SUB Lighting2(sType AS String, sAddress AS String, sCommand AS String, OPTIONAL bGroup AS Boolean)

  DIM bBuf As New Byte[12]
  DIM sCmd AS String = UCase(sCommand)
  DIM aAddr AS String[]
  DIM sUnit AS String
  DIM iDim, iBrightness AS Integer

  ' "AC", "HEEU", "Anslut"
  SELECT CASE UCase(sType)
    CASE "AC"
      bBuf[2] = 0
    CASE "HEEU"
      bBuf[2] = 1
    CASE "ANSLUT"
      bBuf[2] = 2
    CASE ELSE
      WriteMessage("[RFXComTRX] Not a valid Lighting2 type : " & sType)
      RETURN
  END SELECT

  aAddr = Split(sAddress, " ")
  IF aAddr.Count = 2 THEN
    sAddress = aAddr[0]
    sUnit = aAddr[1]
    IF LCase(sUnit) = "group" THEN
      bGroup = TRUE
      sUnit = 0
    ENDIF
  ELSE
    Main.WriteDebugLog(("[RFXComTRX] Address has wrong Format, use '<Device> <Unit>'!"))
    RETURN
  ENDIF

  IF Len(sAddress) = 9 AND IF Left(sAddress, 2) = "0x" THEN
    sAddress = Right(sAddress, 7)
  ELSE IF Len(sAddress) <> 7 THEN
    Main.WriteDebugLog(("[RFXComTRX] Device address length must be 7 characters!"))
    RETURN
  ENDIF

  bBuf[0] = 11
  bBuf[1] = pTypeLighting2
  bBuf[3] = iSeq

  bBuf[4] = CByte(Left(sAddress, 1))
  bBuf[5] = CByte(Val("&H" & Mid(sAddress, 2, 2)))
  bBuf[6] = CByte(Val("&H" & Mid(sAddress, 4, 2)))
  bBuf[7] = CByte(Val("&H" & Mid(sAddress, 6, 2)))
  bBuf[8] = CByte(Val(sUnit))

  IF InStr(sCmd, "ALL OFF") OR IF InStr(sCmd, "GROUP OFF") THEN
    bBuf[9] = 3
  ELSE IF InStr(sCmd, "ALL ON") OR IF InStr(sCmd, "GROUP ON") THEN
    bBuf[9] = 4
  ELSE IF InStr(sCmd, "ON") OR IF InStr(sCmd, "DIM 100") THEN
    bBuf[9] = IIf(bGroup, 4, 1)
  ELSE IF InStr(sCmd, "OFF") OR IF InStr(sCmd, "DIM 0") THEN
    bBuf[9] = IIf(bGroup, 3, 0)
  ELSE IF InStr(sCmd, "DIM ") THEN ' DIM 1 - 99
    iBrightness = Val(Replace(sCmd, "DIM ", ""))
    IF iBrightness > 0 THEN
      iDim = Round(0.16 * iBrightness) ' 16 steps
      bBuf[10] = CByte(iDim)
    ENDIF
    bBuf[9] = IIf(bGroup, 5, 2)
  ELSE
    Main.WriteDebugLog(("[RFXComTRX] Unknown Lighting2 command '") & sCmd & ("' given!"))
    RETURN
  ENDIF
  bBuf[11] = 0
  WriteCommand(bBuf)

END

' ENUM LIGHTING5 AS Byte
' packetlength = 0
' packettype = 1
' subtype = 2
' seqnbr = 3
' id1 = 4
' id2 = 5
' id3 = 6
' unitcode = 7
' cmnd = 8
' filler = 9 'bits 3-0
' rssi = 9   'bits 7-4
' size = 9
'
' pType = &H14
' sTypeLightwaveRF = &H0
'
' sOff = 0
' sOn = 1
' sGroupOff = 2
' sMood1 = 3
' sMood2 = 4
' sMood3 = 5
' sUnlock = 6
' sLock = 7
' sAllLock = 8
' END ENUM

' Lightning5
PUBLIC SUB Lighting5(sType AS String, sAddress AS String, sCommand AS String)

  Main.WriteDebugLog("Send Lighting5 Not implemented")

END

' ENUM CURTAIN1 AS Integer
'   packetlength = 0
'   packettype = 1
'   subtype = 2
'   seqnbr = 3
'   housecode = 4
'   unitcode = 5
'   cmnd = 6
'   filler = 7
'   size = 7
'   pType = &H18
'   Harrison = &H0
' END ENUM

' Curtain1
PUBLIC SUB Curtain(sType AS String, sAddress AS String, sCommand AS String)

  Main.WriteDebugLog("Send Curtain Not implemented")

END

' implement properties
PRIVATE FUNCTION TCPHost_Read() AS String

  RETURN sTCPHost

END

PRIVATE SUB TCPHost_Write(Value AS String)

  sTCPHost = Value

END

PRIVATE FUNCTION TCPPort_Read() AS Integer

  RETURN iTCPPort

END

PRIVATE SUB TCPPort_Write(Value AS Integer)

  iTCPPort = Value

END

PRIVATE FUNCTION RFXComDebug_Read() AS Boolean

  RETURN bRFXComTRXDebug

END

PRIVATE SUB RFXComDebug_Write(Value AS Boolean)

  bRFXComTRXDebug = Value

END
